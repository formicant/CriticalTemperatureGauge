/*

# ToolbarController Wrapper

This is a wrapper around the [ToolbarControl][1] mod
that allows using it without a hard dependency.

ToolbarController functionality will be available
only if the ToolbarController mod is installed.
Otherwise, it will fall back to the KSP AppLauncher toolbar.

Warning: not all ToolbarController functionality
is currently implemented!

ToolbarController v. 0.1.9.4 is supported.
Other versions may or may not work.

## Do not edit this file

There is nothing in this file that needs to be edited by hand.

## Migration from a hard dependency

- Ensure that all the ToolbarController functionality used by
  your mod is implemented in this wrapper.
- Ensure that your mod's name does not precede
  `001_ToolbarControl` alphabetically.
- Add this file to your mod's project.
- Replace all the occurrences of the `ToolbarControl_NS` namespace
  with `Wrappers.ToolbarControl_NS`.
- In the _AssemblyInfo.cs_ file, remove the line
  `[assembly: KSPAssemblyDependency("ToolbarController", 1, 0)]`.
- Remove _ToolbarController_ assembly from your project dependencies.

## License

[GNU Lesser General Public License v3.0][2].

[1]: https://github.com/linuxgurugamer/ToolbarControl
[2]: https://www.gnu.org/licenses/lgpl-3.0.en.html

*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using KSP.UI.Screens;
using UnityEngine;

namespace Wrappers.ToolbarControl_NS
{
	public class ToolbarControl : MonoBehaviour
	{
		#region Public

		/// <summary>Whether the ToolbarController mod is installed.</summary>
		public static bool IsModInstalled { get; }

		// TODO: Add functionality!

		public static bool RegisterMod(string NameSpace, string DisplayName = "", bool useBlizzy = false, bool useStock = true, bool NoneAllowed = true) =>
			_registerMod(NameSpace, DisplayName, useBlizzy, useStock, NoneAllowed);

		public static bool BlizzyActive(string NameSpace, bool? useBlizzy = null) => _blizzyActive(NameSpace, useBlizzy);
		public static bool StockActive(string NameSpace, bool? useStock = null) => _stockActive(NameSpace, useStock);

		public delegate void TC_ClickHandler();


		public void AddToAllToolbars(TC_ClickHandler onTrue, TC_ClickHandler onFalse, ApplicationLauncher.AppScenes visibleInScenes, string nameSpace, string toolbarId, string largeToolbarIcon, string smallToolbarIcon, string toolTip = null) =>
			AddToAllToolbars(onTrue, onFalse, null, null, null, null, visibleInScenes, nameSpace, toolbarId, largeToolbarIcon, largeToolbarIcon, smallToolbarIcon, smallToolbarIcon, toolTip);

		public void AddToAllToolbars(TC_ClickHandler onTrue, TC_ClickHandler onFalse, ApplicationLauncher.AppScenes visibleInScenes, string nameSpace, string toolbarId, string largeToolbarIconActive, string largeToolbarIconInactive, string smallToolbarIconActive, string smallToolbarIconInactive, string toolTip = null) =>
			AddToAllToolbars( onTrue, onFalse, null, null, null, null, visibleInScenes, nameSpace, toolbarId, largeToolbarIconActive, largeToolbarIconInactive, smallToolbarIconActive, smallToolbarIconInactive, toolTip);

		public void AddToAllToolbars(TC_ClickHandler onTrue, TC_ClickHandler onFalse, TC_ClickHandler onHover, TC_ClickHandler onHoverOut, TC_ClickHandler onEnable, TC_ClickHandler onDisable, ApplicationLauncher.AppScenes visibleInScenes, string nameSpace, string toolbarId, string largeToolbarIcon, string smallToolbarIcon, string toolTip = null) =>
			AddToAllToolbars(onTrue, onFalse, onHover, onHoverOut, onEnable, onDisable, visibleInScenes, nameSpace, toolbarId, largeToolbarIcon, largeToolbarIcon, smallToolbarIcon, smallToolbarIcon, toolTip);

		public void AddToAllToolbars(TC_ClickHandler onTrue, TC_ClickHandler onFalse, TC_ClickHandler onHover, TC_ClickHandler onHoverOut, TC_ClickHandler onEnable, TC_ClickHandler onDisable, ApplicationLauncher.AppScenes visibleInScenes, string nameSpace, string toolbarId, string largeToolbarIconActive, string largeToolbarIconInactive, string smallToolbarIconActive, string smallToolbarIconInactive, string toolTip = null)
		{
			var onTrueHandler = new HandlerWrapper(onTrue);
			var onFalseHandler = new HandlerWrapper(onFalse);
			var onHoverHandler = new HandlerWrapper(onHover);
			var onHoverOutHandler = new HandlerWrapper(onHoverOut);
			var onEnableHandler = new HandlerWrapper(onEnable);
			var onDisableHandler = new HandlerWrapper(onDisable);

			if(IsModInstalled)
			{
				_toolbarControl.InvokeMethod(_addToAllToolbars,
					onTrueHandler.ToolbarControlHandler, onFalseHandler.ToolbarControlHandler,
					onHoverHandler.ToolbarControlHandler, onHoverOutHandler.ToolbarControlHandler,
					onEnableHandler.ToolbarControlHandler, onDisableHandler.ToolbarControlHandler,
					visibleInScenes,
					nameSpace, toolbarId,
					largeToolbarIconActive, largeToolbarIconInactive,
					smallToolbarIconActive, smallToolbarIconInactive,
					toolTip);
			}
			else
			{
				_stockOnReady = () => _stockButton = ApplicationLauncher.Instance.AddModApplication(
					onTrueHandler.StockHandler, onFalseHandler.StockHandler,
					onHoverHandler.StockHandler, onHoverOutHandler.StockHandler,
					onEnableHandler.StockHandler, onDisableHandler.StockHandler,
					visibleInScenes,
					GameDatabase.Instance.GetTexture(largeToolbarIconActive, false));
				GameEvents.onGUIApplicationLauncherDestroyed.Add(StockOnDestroy);
				GameEvents.onGUIApplicationLauncherReady.Add(StockOnReady);
				StockOnReady();
			}
		}


		public void UseBlizzy(bool useBlizzy) => _useBlizzy(useBlizzy);
		public void UseStock(bool useStock) => _useStock(useStock);
		public void SetTrue(bool makeCall = false) => _setTrue(makeCall);
		public void SetFalse(bool makeCall = false) => _setFalse(makeCall);

		public void OnDestroy() => _onDestroy();

		public bool Enabled { get => _getEnabled(); set => _setEnabled(value); }
		public bool IsHovering => _getIsHovering();

		#endregion

		#region Private

		readonly Action<bool> _useBlizzy;
		readonly Action<bool> _useStock;
		readonly Action<bool> _setTrue;
		readonly Action<bool> _setFalse;
		readonly Action _onDestroy;

		readonly Func<bool> _getEnabled;
		readonly Action<bool> _setEnabled;
		readonly Func<bool> _getIsHovering;

		readonly object _toolbarControl;

		ApplicationLauncherButton _stockButton;
		Action _stockOnReady;

		public ToolbarControl()
		{
			if(IsModInstalled)
			{
				// instance
				_toolbarControl = Activator.CreateInstance(_class);

				// methods
				_useBlizzy = _toolbarControl.GetMethodDelegate<Action<bool>>(nameof(UseBlizzy));
				_useStock = _toolbarControl.GetMethodDelegate<Action<bool>>(nameof(UseStock));
				_setTrue = _toolbarControl.GetMethodDelegate<Action<bool>>(nameof(SetTrue));
				_setFalse = _toolbarControl.GetMethodDelegate<Action<bool>>(nameof(SetFalse));
				_onDestroy = _toolbarControl.GetMethodDelegate<Action>(nameof(OnDestroy));

				// properties
				_getEnabled = _class.GetPropertyGetDelegate<bool>(nameof(Enabled), _toolbarControl);
				_setEnabled = _class.GetPropertySetDelegate<bool>(nameof(Enabled), _toolbarControl);
				_getIsHovering = _class.GetPropertyGetDelegate<bool>(nameof(IsHovering), _toolbarControl);
			}
			else
			{
				// methods
				_useBlizzy = _ => { };
				_useStock = _ => { };
				_setTrue = makeCall => _stockButton?.SetTrue(makeCall);
				_setFalse = makeCall => _stockButton?.SetFalse(makeCall);
				_onDestroy = StockOnDestroy;

				// properties
				_getEnabled = () => _stockButton?.IsEnabled ?? false;
				_setEnabled = value => { if(value) _stockButton?.Enable(); else _stockButton?.Disable(); };
				_getIsHovering = () => _stockButton?.IsHovering ?? false;
			}
		}

		void StockOnReady()
		{
			if(ApplicationLauncher.Ready && _stockButton is null)
				_stockOnReady();
		}

		void StockOnDestroy()
		{
			if(_stockButton is object)
			{
				GameEvents.onGUIApplicationLauncherDestroyed.Remove(StockOnDestroy);
				GameEvents.onGUIApplicationLauncherReady.Remove(StockOnReady);
				ApplicationLauncher.Instance.RemoveModApplication(_stockButton);
				_stockButton = null;
			}
		}


		const string AssemblyName = "ToolbarController";

		static readonly Type _class;
		static readonly Type _clickHandlerType;
		static readonly MethodInfo _addToAllToolbars;

		static readonly Func<string, string, bool, bool, bool, bool> _registerMod = (n, d, uB, uS, nA) => true;
		static readonly Func<string, bool?, bool> _blizzyActive = (n, uB) => false;
		static readonly Func<string, bool?, bool> _stockActive = (n, uS) => true;

		static ToolbarControl()
		{
			var assembly = AssemblyLoader.loadedAssemblies
				.FirstOrDefault(a => a.name.Equals(AssemblyName, StringComparison.Ordinal))
				?.assembly;

			IsModInstalled = assembly is object;
			Debug.Log($"[{nameof(Wrappers)}]: {AssemblyName} is {(IsModInstalled ? "" : "NOT ")}available.");

			if(IsModInstalled)
			{
				// types
				_class = assembly.GetType($"{nameof(ToolbarControl_NS)}.{nameof(ToolbarControl)}");
				_clickHandlerType = _class.GetNestedType(nameof(TC_ClickHandler));

				// static methods
				_registerMod = _class.GetMethodDelegate<Func<string, string, bool, bool, bool, bool>>(nameof(RegisterMod));
				_blizzyActive = _class.GetMethodDelegate<Func<string, bool?, bool>>(nameof(BlizzyActive));
				_stockActive = _class.GetMethodDelegate<Func<string, bool?, bool>>(nameof(StockActive));

				// instance methods
				_addToAllToolbars = _class.GetMethods(nameof(AddToAllToolbars)).ByArgumentCount(14);
			}
		}

		class HandlerWrapper
		{
			public HandlerWrapper(TC_ClickHandler handler)
			{
				_handler = handler;
				ToolbarControlHandler = _clickHandlerType is object && _handler is object
					? Delegate.CreateDelegate(_clickHandlerType, this, nameof(HandlerMethod))
					: null;
				StockHandler = _handler is object
					? () => _handler()
					: (Callback) null;
			}

			public Delegate ToolbarControlHandler { get; }
			public Callback StockHandler { get; }

			void HandlerMethod() => _handler();
			readonly TC_ClickHandler _handler;
		}

		#endregion
	}

	#region Extensions

	static class WrapperExtensions
	{
		public static TSignature GetMethodDelegate<TSignature>(this Type type, string methodName) where TSignature : Delegate =>
			(TSignature) Delegate.CreateDelegate(typeof(TSignature), type, methodName);

		public static TSignature GetMethodDelegate<TSignature>(this object instance, string methodName) where TSignature : Delegate =>
			(TSignature) Delegate.CreateDelegate(typeof(TSignature), instance, methodName);

		public static Func<T> GetPropertyGetDelegate<T>(this Type type, string propertyName, object instance) =>
			(Func<T>) type.GetProperty(propertyName).GetMethod.CreateDelegate(typeof(Func<T>), instance);

		public static Action<T> GetPropertySetDelegate<T>(this Type type, string propertyName, object instance) =>
			(Action<T>) type.GetProperty(propertyName).SetMethod.CreateDelegate(typeof(Action<T>), instance);

		public static IReadOnlyList<MethodInfo> GetMethods(this Type type, string name) =>
			type.GetMethods().Where(m => m.Name.Equals(name, StringComparison.Ordinal)).ToArray();

		public static MethodInfo ByArgumentCount(this IEnumerable<MethodInfo> methods, int argumentCount) =>
			methods.First(m => m.GetParameters().Length == argumentCount);

		public static object InvokeMethod(this object instance, MethodInfo method, params object[] arguments) =>
			method.Invoke(instance, arguments);
	}

	#endregion
}
